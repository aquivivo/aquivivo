<!doctype html>
<html lang="pl">
  <head>
    <meta charset="UTF-8" />
    <title>A1 vocab .xlsx ‚Üí Firestore (AquiVivo)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../assets/css/styles.css?v=20260209a" />
    <style>
      body {
        font-family: Arial, sans-serif;
        padding: 20px;
      }
      .box {
        margin-top: 12px;
        padding: 12px;
        border: 1px solid var(--border-light);
        border-radius: 10px;
      }
      button {
        padding: 10px 14px;
        font-weight: 900;
        cursor: pointer;
      }
      code {
        background: #f3f4f6;
        padding: 2px 6px;
        border-radius: 6px;
      }
      .ok {
        color: var(--success-ink);
        font-weight: 900;
      }
      .err {
        color: var(--danger-ink);
        font-weight: 900;
      }
      .muted {
        color: var(--ink-muted);
      }
      .grid2 {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }
      @media (max-width: 860px) {
        .grid2 {
          grid-template-columns: 1fr;
        }
      }
      .mapTable {
        width: 100%;
        border-collapse: collapse;
      }
      .mapTable th,
      .mapTable td {
        text-align: left;
        border-bottom: 1px solid rgba(0, 0, 0, 0.08);
        padding: 10px 8px;
        vertical-align: top;
      }
      .mapTable th {
        font-size: 12px;
        opacity: 0.8;
      }
      .small {
        font-size: 12px;
      }
      .pillMini {
        display: inline-flex;
        align-items: center;
        padding: 2px 8px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.06);
        font-size: 12px;
        font-weight: 800;
        margin-left: 6px;
      }
      .select {
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border-light);
        font-weight: 700;
        min-width: 260px;
      }
      .input {
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border-light);
        font-weight: 700;
      }
      .row {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      .row label {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        font-weight: 800;
      }
      .logLine {
        margin-top: 6px;
        line-height: 1.5;
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  </head>
  <body>
    <div
      style="
        background: var(--yellow);
        color: var(--blue);
        padding: 8px;
        text-align: center;
        font-size: 12px;
        font-weight: 700;
        margin-bottom: 14px;
      "
    >
      Sesi√≥n activa:
      <strong id="sessionEmail" style="color: var(--blue); font-weight: 900"
        >Cargando...</strong
      >
    </div>

    <h2>üìö Import: A1 vocab .xlsx ‚Üí lekcje + ƒáwiczenia (A1)</h2>
    <p class="muted">
      Wgra: s≈Çownictwo do <code>course_meta.vocab</code> + ƒáwiczenia do
      <code>exercises</code> (fiszki, luki, wyb√≥r, listening, speaking, test).
      Wymaga admin: <code>aquivivo.pl@gmail.com</code>.
    </p>

    <div class="grid2">
      <div class="box">
        <div style="font-weight: 900">1) Plik XLSX</div>
        <div class="row" style="margin-top: 10px">
          <input id="xlsxFile" type="file" accept=".xlsx" />
          <button id="btnParse" class="btn-white-outline" type="button">
            Wczytaj XLSX
          </button>
          <span id="fileStatus" class="muted small"></span>
        </div>
        <div class="muted small" style="margin-top: 10px">
          Wykryjƒô zak≈Çadki i poka≈ºƒô mapowanie na tematy A1.
        </div>
      </div>

      <div class="box">
        <div style="font-weight: 900">2) Tematy A1 (Firestore)</div>
        <div class="row" style="margin-top: 10px">
          <button id="btnLoadTopics" class="btn-white-outline" type="button">
            Wczytaj tematy A1
          </button>
          <span id="topicsStatus" class="muted small"></span>
        </div>
        <div class="muted small" style="margin-top: 10px">
          Je≈õli co≈õ siƒô nie dopasuje po nazwie ‚Äî zmienisz rƒôcznie w tabeli.
        </div>
      </div>
    </div>

    <div class="box" style="margin-top: 12px">
      <div style="font-weight: 900">3) Opcje importu</div>

      <div class="row" style="margin-top: 10px">
        <label
          ><input id="optUpdateMeta" type="checkbox" checked /> Zapisz
          <code>course_meta.vocab</code></label
        >
        <label
          ><input id="optCleanup" type="checkbox" checked /> Usu≈Ñ poprzednie
          ƒáwiczenia z tego importu</label
        >
      </div>

      <div class="row" style="margin-top: 10px">
        <label
          ><input id="optCards" type="checkbox" checked /> Fiszki (Quizlet)</label
        >
        <label
          ><input id="optFill" type="checkbox" checked /> Luki (pisanie)</label
        >
        <label
          ><input id="optChoice" type="checkbox" checked /> Wyb√≥r (quiz)</label
        >
        <label
          ><input id="optListenFill" type="checkbox" checked /> Listening + luki</label
        >
        <label
          ><input id="optListenChoice" type="checkbox" checked /> Listening + wyb√≥r</label
        >
        <label
          ><input id="optSpeak" type="checkbox" checked /> Speaking (nagrywanie)</label
        >
        <label
          ><input id="optTF" type="checkbox" /> Prawda / fa≈Çsz</label
        >
        <label
          ><input id="optTest" type="checkbox" checked /> Test ko≈Ñcowy</label
        >
      </div>

      <div class="row" style="margin-top: 10px">
        <label class="small"
          >Limit na typ / temat (0 = wszystko):
          <input
            id="optLimit"
            class="input"
            style="width: 90px"
            type="number"
            value="12"
            min="0"
        /></label>
        <label class="small"
          >Pytania w te≈õcie:
          <input
            id="optTestN"
            class="input"
            style="width: 90px"
            type="number"
            value="6"
            min="1"
            max="30"
        /></label>
        <label class="small"
          >Fiszki na 1 dokument:
          <input
            id="optCardsChunk"
            class="input"
            style="width: 90px"
            type="number"
            value="40"
            min="10"
            max="120"
        /></label>
      </div>

      <div class="muted small" style="margin-top: 10px">
        Tip: Je≈õli chcesz ‚Äûwszystko‚Äù, ustaw limit na <code>0</code>. Przy du≈ºych
        setach mo≈ºe to chwilƒô potrwaƒá.
      </div>
    </div>

    <div class="box" style="margin-top: 12px">
      <div style="font-weight: 900">4) Mapowanie: zak≈Çadka XLSX ‚Üí temat A1</div>
      <div id="mappingWrap" class="muted small" style="margin-top: 10px">
        (najpierw wczytaj XLSX i tematy A1)
      </div>
    </div>

    <button id="btnImportAll" class="btn-yellow" style="margin-top: 12px">
      IMPORTUJ WSZYSTKO (A1)
    </button>

    <div id="log" class="box">
      <div class="logLine">Status: gotowe.</div>
    </div>

    <script type="module">
      import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.8.0/firebase-app.js';
      import {
        getAuth,
        onAuthStateChanged,
      } from 'https://www.gstatic.com/firebasejs/12.8.0/firebase-auth.js';
      import {
        getFirestore,
        collection,
        doc,
        getDocs,
        query,
        where,
        orderBy,
        setDoc,
        serverTimestamp,
        writeBatch,
      } from 'https://www.gstatic.com/firebasejs/12.8.0/firebase-firestore.js';

      const firebaseConfig = {
        apiKey: 'AIzaSyBoa3Yf82CDW6k1FSwdeoQg-gBTjh9kVZM',
        authDomain: 'aquivivo-platform.firebaseapp.com',
        projectId: 'aquivivo-platform',
        storageBucket: 'aquivivo-platform.firebasestorage.app',
        messagingSenderId: '116115622011',
        appId: '1:116115622011:web:33a4a583eba4368071bade',
      };

      const ADMIN_EMAIL = 'aquivivo.pl@gmail.com';
      const LEVEL = 'A1';
      const SEED_SOURCE = 'a1_vocab_xlsx';
      const SEED_VERSION = 'a1_vocab_xlsx_v1_2026-02-09';

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      const $ = (id) => document.getElementById(id);

      const sessionEl = $('sessionEmail');
      const fileStatus = $('fileStatus');
      const topicsStatus = $('topicsStatus');
      const mappingWrap = $('mappingWrap');
      const logEl = $('log');

      function log(line, type = '') {
        const div = document.createElement('div');
        div.className = `logLine ${type}`.trim();
        div.innerHTML = line;
        logEl.appendChild(div);
      }

      function esc(s) {
        return String(s || '')
          .replaceAll('&', '&amp;')
          .replaceAll('<', '&lt;')
          .replaceAll('>', '&gt;')
          .replaceAll('"', '&quot;')
          .replaceAll("'", '&#039;');
      }

      function normalizeText(value) {
        return String(value || '')
          .toLowerCase()
          .normalize('NFD')
          .replace(/[\u0300-\u036f]/g, '')
          .replace(/[^a-z0-9]+/g, ' ')
          .trim();
      }

      function stripSheetName(name) {
        let s = String(name || '').trim();
        s = s.replace(/^[^A-Za-z0-9]+\s*/g, '');
        s = s.replace(/^a1\s*[-‚Äî:]+?\s*/i, '');
        s = s.replace(/^vocabulario\s*a1\s*[-‚Äî:]+?\s*/i, '');
        s = s.replace(/^vocabulario\s*[-‚Äî:]+?\s*/i, '');
        return s.trim();
      }

      function bestTopicMatch(sheetName, topics) {
        const raw = stripSheetName(sheetName);
        const sheetKey = normalizeText(raw);
        if (!sheetKey) return '';

        let best = { score: 0, id: '' };
        for (const t of topics || []) {
          const title = String(t?.title || t?.name || '').trim();
          const slug = String(t?.slug || '').trim();
          const key = normalizeText(title || slug);
          if (!key) continue;

          let score = 0;
          const tokens = sheetKey.split(' ').filter(Boolean);
          const hits = tokens.filter((tok) => key.includes(tok)).length;
          score += hits * 2;
          if (key.includes(sheetKey) || sheetKey.includes(key)) score += 6;
          if (normalizeText(title).includes(sheetKey)) score += 4;
          if (normalizeText(slug).includes(sheetKey)) score += 2;
          if (score > best.score) best = { score, id: t.id };
        }
        return best.score >= 4 ? best.id : '';
      }

      function safeCell(v) {
        return String(v ?? '').trim();
      }

      function pickRowValue(row, keys) {
        const obj = row || {};
        for (const k of keys) {
          if (k in obj) return safeCell(obj[k]);
        }
        const want = keys.map((x) => normalizeText(x));
        for (const [kk, vv] of Object.entries(obj)) {
          const n = normalizeText(kk);
          if (!n) continue;
          if (want.some((w) => w && n.includes(w))) return safeCell(vv);
        }
        return '';
      }

      function sanitizeCardText(s) {
        return String(s || '').replaceAll('|', ' / ').replaceAll('\n', ' ').trim();
      }

      function escapeRegExp(s) {
        return String(s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      }

      function aliasesForTerm(pl) {
        const raw = String(pl || '').trim();
        if (!raw) return [];
        const noParen = raw.replace(/\([^)]*\)/g, '').trim();
        const parts = raw
          .split('/')
          .map((p) => p.replace(/\([^)]*\)/g, '').trim())
          .filter(Boolean);
        const base = noParen || raw;
        const list = [...new Set([base, ...parts].filter(Boolean))];
        return list.sort((a, b) => b.length - a.length);
      }

      function blankExample(examplePl, plTerm) {
        const text = String(examplePl || '').trim();
        if (!text) return '';
        const aliases = aliasesForTerm(plTerm);
        for (const a of aliases) {
          const re = new RegExp(escapeRegExp(a), 'i');
          if (re.test(text)) return text.replace(re, '___');
        }
        return '';
      }

      function sampleRows(rows, n) {
        const list = Array.isArray(rows) ? rows : [];
        const limit = Number(n || 0);
        if (!limit || limit <= 0) return list;
        return list.slice(0, limit);
      }

      function shuffledUnique(list, seed) {
        const arr = [...new Set((list || []).filter(Boolean))];
        if (!arr.length) return arr;
        const s = Math.abs(Number(seed || 0)) % arr.length;
        return arr.slice(s).concat(arr.slice(0, s));
      }

      function buildChoiceOptions(correct, pool, want = 4) {
        const uniq = [...new Set(pool.filter(Boolean))].filter((x) => x !== correct);
        const out = [correct];
        for (const x of uniq) {
          if (out.length >= want) break;
          out.push(x);
        }
        return out;
      }

      function makeExerciseDoc({ topic, order, type, prompt, options, answer, notes, tags }) {
        return {
          level: LEVEL,
          topicId: topic.id,
          topicSlug: String(topic.slug || topic.id),
          order: Number(order || 0),
          type: String(type || ''),
          prompt: String(prompt || ''),
          options: Array.isArray(options) ? options : [],
          answer: String(answer || ''),
          notes: String(notes || ''),
          tags: Array.isArray(tags) ? tags : [],
          category: 'vocabulary',
          seedSource: SEED_SOURCE,
          seedVersion: SEED_VERSION,
          updatedAt: serverTimestamp(),
          createdAt: serverTimestamp(),
        };
      }

      function exId(topicId, kind, seq) {
        const n = String(seq).padStart(3, '0');
        const k = String(kind || 'X').toUpperCase().replace(/[^A-Z0-9_]+/g, '_');
        return `${LEVEL}__${topicId}__XLSX__${k}__${n}`;
      }

      let IS_ADMIN = false;
      let parsedSheets = []; // [{name, rows:[{pl,es,phon,exPl,exEs,section}], rawCount}]
      let topics = []; // Firestore topics A1
      let mapping = new Map(); // sheetName -> topicId

      onAuthStateChanged(auth, (user) => {
        if (sessionEl) sessionEl.textContent = user?.email || '(sin sesi√≥n)';
        IS_ADMIN =
          !!user &&
          String(user.email || '').toLowerCase() === ADMIN_EMAIL.toLowerCase();
        if (!IS_ADMIN) {
          log(
            `‚ùå Zaloguj siƒô jako admin (${esc(ADMIN_EMAIL)}), potem wr√≥ƒá na tƒô stronƒô.`,
            'err',
          );
        }
      });

      function rebuildMappingUI() {
        if (!mappingWrap) return;
        if (!parsedSheets.length || !topics.length) {
          mappingWrap.textContent = '(najpierw wczytaj XLSX i tematy A1)';
          return;
        }

        const optionsHtml = [
          `<option value="">-- (pomi≈Ñ) --</option>`,
          ...topics.map((t) => {
            const label = `${Number(t.order || 0)}. ${t.title || t.name || t.slug || t.id} (${t.type || 'grammar'})`;
            return `<option value="${esc(t.id)}">${esc(label)}</option>`;
          }),
        ].join('');

        const rowsHtml = parsedSheets
          .map((s) => {
            return `
              <tr>
                <td>
                  <div style="font-weight:900;">${esc(s.name)}</div>
                  <div class="muted small">
                    ${esc(stripSheetName(s.name)) || '-'}
                    <span class="pillMini">${Number(s.rows?.length || 0)} s≈Ç√≥w</span>
                  </div>
                </td>
                <td>
                  <select class="select mapSelect" data-sheet="${esc(s.name)}">
                    ${optionsHtml}
                  </select>
                </td>
              </tr>
            `;
          })
          .join('');

        mappingWrap.innerHTML = `
          <table class="mapTable">
            <thead>
              <tr>
                <th>Zak≈Çadka (XLSX)</th>
                <th>Temat (A1)</th>
              </tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
          <div class="muted small" style="margin-top:10px;">
            Je≈õli chcesz przypisaƒá zak≈Çadkƒô do innego tematu ‚Äî zmie≈Ñ select.
          </div>
        `;

        mappingWrap.querySelectorAll('select.mapSelect').forEach((sel) => {
          const sheet = sel.getAttribute('data-sheet') || '';
          const current = mapping.get(sheet) || '';
          sel.value = current;
          sel.addEventListener('change', () => {
            mapping.set(sheet, sel.value || '');
          });
        });
      }

      function parseXlsxFile(file) {
        return new Promise((resolve, reject) => {
          try {
            const reader = new FileReader();
            reader.onload = (e) => {
              try {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, { type: 'array' });
                resolve(wb);
              } catch (err) {
                reject(err);
              }
            };
            reader.onerror = () => reject(reader.error);
            reader.readAsArrayBuffer(file);
          } catch (e) {
            reject(e);
          }
        });
      }

      function sheetRowsFromWorkbook(wb) {
        const out = [];
        const sheetNames = wb?.SheetNames || [];
        sheetNames.forEach((name) => {
          const ws = wb.Sheets[name];
          if (!ws) return;
          const json = XLSX.utils.sheet_to_json(ws, { defval: '' });
          const rows = (json || [])
            .map((row) => {
              const pl = pickRowValue(row, ['Polski', 'PL', 'Polaco']);
              const es = pickRowValue(row, [
                'Espa√±ol (LATAM)',
                'Espanol (LATAM)',
                'Espa√±ol',
                'Espanol',
                'ES',
                'Espa√±ol (ES)',
              ]);
              const phon = pickRowValue(row, [
                'Fonetyka',
                'Fonetyka (para latinos ‚Äì lectura del polaco)',
                'Fonetyka (para latinos - lectura del polaco)',
              ]);
              const section = pickRowValue(row, ['Secci√≥n', 'Seccion', 'Sekcja']);
              const exPl = pickRowValue(row, [
                'Ejemplo de uso (PL)',
                'Ejemplo (PL)',
                'Przyk≈Çad (PL)',
              ]);
              const exEs = pickRowValue(row, [
                'Ejemplo de uso (ES)',
                'Ejemplo (ES)',
                'Przyk≈Çad (ES)',
              ]);

              return {
                pl: safeCell(pl),
                es: safeCell(es),
                phon: safeCell(phon),
                section: safeCell(section),
                exPl: safeCell(exPl),
                exEs: safeCell(exEs),
              };
            })
            .filter((r) => r.pl || r.es || r.exPl);

          out.push({ name, rows, rawCount: rows.length });
        });
        return out;
      }

      async function loadTopicsA1() {
        const q = query(
          collection(db, 'courses'),
          where('level', '==', LEVEL),
          orderBy('order'),
        );
        const snap = await getDocs(q);
        return snap.docs
          .map((d) => ({ id: d.id, ...(d.data() || {}) }))
          .filter((t) => t.isArchived !== true);
      }

      function computeDefaultMapping() {
        mapping = new Map();
        parsedSheets.forEach((s) => {
          const key = normalizeText(stripSheetName(s.name));
          if (!key) return;
          const id = bestTopicMatch(s.name, topics);
          mapping.set(s.name, id || '');
        });
      }

      $('btnParse').addEventListener('click', async () => {
        if (!IS_ADMIN) {
          alert('Nie jeste≈õ adminem.');
          return;
        }
        const file = $('xlsxFile')?.files?.[0] || null;
        if (!file) {
          alert('Wybierz plik .xlsx.');
          return;
        }
        if (fileStatus) fileStatus.textContent = '‚è≥ Wczytujƒô...';
        try {
          const wb = await parseXlsxFile(file);
          const sheets = sheetRowsFromWorkbook(wb);
          parsedSheets = sheets.filter(
            (s) => !normalizeText(s.name).includes('rodzaje zadan'),
          );
          if (fileStatus)
            fileStatus.textContent = `‚úÖ OK (${parsedSheets.length} zak≈Çadek)`;
          log(
            `‚úÖ XLSX wczytany. Zak≈Çadki: <code>${esc(parsedSheets.map((s) => s.name).join(' | '))}</code>`,
            'ok',
          );
          if (topics.length) {
            computeDefaultMapping();
            rebuildMappingUI();
          }
        } catch (e) {
          console.error(e);
          if (fileStatus) fileStatus.textContent = '‚ùå B≈ÇƒÖd';
          log('‚ùå Nie mogƒô wczytaƒá XLSX. Sprawd≈∫ konsolƒô.', 'err');
        }
      });

      $('btnLoadTopics').addEventListener('click', async () => {
        if (!IS_ADMIN) {
          alert('Nie jeste≈õ adminem.');
          return;
        }
        if (topicsStatus) topicsStatus.textContent = '‚è≥ Wczytujƒô...';
        try {
          topics = await loadTopicsA1();
          if (topicsStatus) topicsStatus.textContent = `‚úÖ OK (${topics.length})`;
          log(`‚úÖ Wczytano tematy A1 z Firestore: <code>${topics.length}</code>`, 'ok');
          if (parsedSheets.length) computeDefaultMapping();
          rebuildMappingUI();
        } catch (e) {
          console.error(e);
          if (topicsStatus) topicsStatus.textContent = '‚ùå B≈ÇƒÖd';
          log('‚ùå Nie mogƒô wczytaƒá temat√≥w A1. Sprawd≈∫ konsolƒô.', 'err');
        }
      });

      async function deleteOldSeededExercisesForTopic(topicId) {
        const snap = await getDocs(
          query(collection(db, 'exercises'), where('topicId', '==', topicId)),
        );
        const refs = [];
        snap.forEach((d) => {
          const data = d.data() || {};
          if (String(data.seedSource || '') === SEED_SOURCE) refs.push(d.ref);
        });
        if (!refs.length) return 0;

        let deleted = 0;
        for (let i = 0; i < refs.length; i += 450) {
          const batch = writeBatch(db);
          refs.slice(i, i + 450).forEach((r) => batch.delete(r));
          await batch.commit();
          deleted += Math.min(450, refs.length - i);
        }
        return deleted;
      }

      async function commitSetDocs(pairs) {
        let done = 0;
        for (let i = 0; i < pairs.length; i += 450) {
          const batch = writeBatch(db);
          pairs.slice(i, i + 450).forEach((p) => batch.set(p.ref, p.data, { merge: true }));
          await batch.commit();
          done += Math.min(450, pairs.length - i);
        }
        return done;
      }

      function buildVocabItems(rows) {
        const out = [];
        const seen = new Set();
        (rows || []).forEach((r) => {
          const pl = String(r.pl || '').trim();
          const es = String(r.es || '').trim();
          if (!pl && !es) return;
          const line = pl && es ? `${pl} ‚Äî ${es}` : pl || es;
          const key = normalizeText(line);
          if (!key || seen.has(key)) return;
          seen.add(key);
          out.push(line);
        });
        return out;
      }

      function buildExercisesForTopic(topic, sheetName, rows, opt) {
        const limit = Number(opt.limit || 0);
        const testN = Math.max(1, Number(opt.testN || 6));
        const chunkSize = Math.max(10, Number(opt.cardsChunk || 40));

        const plPool = rows.map((r) => String(r.pl || '').trim()).filter(Boolean);
        const esPool = rows.map((r) => String(r.es || '').trim()).filter(Boolean);

        const exercises = [];
        let order = 1;

        const tagBase = [
          'a1',
          'xlsx',
          'vocab',
          `sheet:${stripSheetName(sheetName)}`.slice(0, 40),
        ];

        if (opt.fill) {
          const fillRows = sampleRows(
            rows.filter((r) => r.pl && (r.exPl || r.es)),
            limit,
          );
          fillRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const es = String(r.es || '').trim();
            const exPl = String(r.exPl || '').trim();
            const exEs = String(r.exEs || '').trim();
            const blank =
              blankExample(exPl, pl) ||
              (es ? `Traduce al polaco: ${es} ‚Üí ___` : 'Completa: ___');
            const notes = [
              r.phon ? `Pron: ${sanitizeCardText(r.phon)}` : '',
              exEs ? `ES: ${sanitizeCardText(exEs)}` : '',
            ]
              .filter(Boolean)
              .join(' | ');

            exercises.push({
              id: exId(topic.id, 'FILL', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Rellenar los espacios',
                prompt: blank,
                options: [],
                answer: pl,
                notes,
                tags: [...tagBase, 'type:fill'],
              }),
            });
          });
        }

        if (opt.choice) {
          const choiceRows = sampleRows(rows.filter((r) => r.pl && r.es), limit);
          choiceRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const es = String(r.es || '').trim();
            const pool = shuffledUnique(plPool, idx + 3);
            const opts = buildChoiceOptions(pl, pool, 4);
            const options = shuffledUnique(opts, idx + 1);
            const notes = r.phon ? `Pron: ${sanitizeCardText(r.phon)}` : '';

            exercises.push({
              id: exId(topic.id, 'CHOICE', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Opci√≥n m√∫ltiple',
                prompt: `¬øC√≥mo se dice en polaco: "${es}"?`,
                options,
                answer: pl,
                notes,
                tags: [...tagBase, 'type:choice'],
              }),
            });
          });
        }

        if (opt.listenFill) {
          const listenFillRows = sampleRows(
            rows.filter((r) => (r.exPl || r.pl) && r.pl),
            limit ? Math.max(1, Math.floor(limit * 0.75)) : 0,
          );
          listenFillRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const exPl = String(r.exPl || '').trim();
            const exEs = String(r.exEs || '').trim();
            const blank = blankExample(exPl, pl) || 'Completa: ___';
            const tts = exPl || pl;
            const notes = [
              `TTS_PL: ${sanitizeCardText(tts)}`,
              exEs ? `ES: ${sanitizeCardText(exEs)}` : '',
            ]
              .filter(Boolean)
              .join(' | ');

            exercises.push({
              id: exId(topic.id, 'LISTEN_FILL', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Escuchar y completar los espacios',
                prompt: blank,
                options: [],
                answer: pl,
                notes,
                tags: [...tagBase, 'type:listen_fill'],
              }),
            });
          });
        }

        if (opt.listenChoice) {
          const listenChoiceRows = sampleRows(
            rows.filter((r) => r.pl && r.es),
            limit ? Math.max(1, Math.floor(limit * 0.75)) : 0,
          );
          listenChoiceRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const es = String(r.es || '').trim();
            const pool = shuffledUnique(esPool, idx + 7);
            const opts = buildChoiceOptions(es, pool, 4);
            const options = shuffledUnique(opts, idx + 2);
            const notes = `TTS_PL: ${sanitizeCardText(pl)}`;

            exercises.push({
              id: exId(topic.id, 'LISTEN_CHOICE', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Escuchar y elegir la respuesta',
                prompt: 'Escucha (PL) y elige la traducci√≥n en espa√±ol.',
                options,
                answer: es,
                notes,
                tags: [...tagBase, 'type:listen_choice'],
              }),
            });
          });
        }

        if (opt.speak) {
          const speakRows = sampleRows(
            rows.filter((r) => r.exPl || r.pl),
            limit ? Math.max(1, Math.floor(limit * 0.5)) : 0,
          );
          speakRows.forEach((r, idx) => {
            const tts = String(r.exPl || r.pl || '').trim();
            if (!tts) return;
            const notes = [
              `TTS_PL: ${sanitizeCardText(tts)}`,
              r.exEs ? `ES: ${sanitizeCardText(r.exEs)}` : '',
            ]
              .filter(Boolean)
              .join(' | ');

            exercises.push({
              id: exId(topic.id, 'SPEAK', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Escuchar y repetir (voz)',
                prompt: `Powt√≥rz: ${tts}`,
                options: [],
                answer: '',
                notes,
                tags: [...tagBase, 'type:speak'],
              }),
            });
          });
        }

        if (opt.tf) {
          const tfRows = sampleRows(
            rows.filter((r) => r.pl && r.es),
            limit ? Math.max(1, Math.floor(limit * 0.5)) : 0,
          );
          tfRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const es = String(r.es || '').trim();
            const wrong =
              shuffledUnique(esPool.filter((x) => x !== es), idx + 9)[0] || '';
            const makeFalse = idx % 2 === 1 && !!wrong;
            const shown = makeFalse ? wrong : es;
            const answer = makeFalse ? 'Falso' : 'Verdadero';

            exercises.push({
              id: exId(topic.id, 'TF', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Verdadero o falso',
                prompt: `Verdadero/Falso: "${pl}" = "${shown}"`,
                options: ['Verdadero', 'Falso'],
                answer,
                notes: '',
                tags: [...tagBase, 'type:tf'],
              }),
            });
          });
        }

        if (opt.cards) {
          const all = rows.filter((r) => r.pl && r.es);
          const lines = all.map((r) => {
            const pl = sanitizeCardText(r.pl);
            const es = sanitizeCardText(r.es);
            const phon = r.phon ? `Pron: ${sanitizeCardText(r.phon)} ¬∑ ` : '';
            const exPl = r.exPl ? sanitizeCardText(r.exPl) : '';
            const exEs = r.exEs ? sanitizeCardText(r.exEs) : '';
            const ex = `${phon}${exPl}${exEs ? ` / ES: ${exEs}` : ''}`.trim();
            return `PL: ${pl} | ES: ${es}${ex ? ` | EX: ${ex}` : ''}`;
          });

          const chunks = [];
          for (let i = 0; i < lines.length; i += chunkSize) {
            chunks.push(lines.slice(i, i + chunkSize));
          }

          chunks.forEach((opts, idx) => {
            exercises.push({
              id: exId(topic.id, 'CARDS', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Tarjetas interactivas',
                prompt:
                  chunks.length > 1
                    ? `Fichas del tema (${idx + 1}/${chunks.length})`
                    : 'Fichas del tema',
                options: opts,
                answer: '',
                notes: 'Abre ‚ÄúFichas‚Äù para practicar tipo Quizlet.',
                tags: [...tagBase, 'type:cards'],
              }),
            });
          });
        }

        if (opt.test) {
          const testRows = sampleRows(rows.filter((r) => r.pl && r.es), testN);
          testRows.forEach((r, idx) => {
            const pl = String(r.pl || '').trim();
            const es = String(r.es || '').trim();
            const pool = shuffledUnique(plPool, idx + 12);
            const options = shuffledUnique(buildChoiceOptions(pl, pool, 4), idx + 5);

            exercises.push({
              id: exId(topic.id, 'TEST', idx + 1),
              data: makeExerciseDoc({
                topic,
                order: order++,
                type: 'Test final del tema',
                prompt: `Test: ¬øC√≥mo se dice en polaco: "${es}"?`,
                options,
                answer: pl,
                notes: '',
                tags: [...tagBase, 'type:test'],
              }),
            });
          });
        }

        return exercises;
      }

      $('btnImportAll').addEventListener('click', async () => {
        if (!IS_ADMIN) {
          alert('Nie jeste≈õ adminem.');
          return;
        }
        if (!parsedSheets.length) {
          alert('Najpierw wczytaj XLSX.');
          return;
        }
        if (!topics.length) {
          alert('Najpierw wczytaj tematy A1.');
          return;
        }

        const opt = {
          updateMeta: $('optUpdateMeta').checked,
          cleanup: $('optCleanup').checked,
          cards: $('optCards').checked,
          fill: $('optFill').checked,
          choice: $('optChoice').checked,
          listenFill: $('optListenFill').checked,
          listenChoice: $('optListenChoice').checked,
          speak: $('optSpeak').checked,
          tf: $('optTF').checked,
          test: $('optTest').checked,
          limit: Number($('optLimit').value || 0),
          testN: Number($('optTestN').value || 6),
          cardsChunk: Number($('optCardsChunk').value || 40),
        };

        const active = parsedSheets
          .map((s) => ({ sheet: s, topicId: mapping.get(s.name) || '' }))
          .filter((x) => !!x.topicId);

        if (!active.length) {
          alert('Brak mapowania. Wybierz tematy w tabeli.');
          return;
        }

        log('‚Äî', '');
        log(`‚è≥ Start importu. Tematy: <code>${active.length}</code>`, '');

        try {
          for (const entry of active) {
            const topic = topics.find((t) => t.id === entry.topicId);
            if (!topic) continue;

            log(
              `‚è≥ Temat: <b>${esc(topic.title || topic.name || topic.id)}</b> (zak≈Çadka: <code>${esc(entry.sheet.name)}</code>)`,
              '',
            );

            if (opt.cleanup) {
              const deleted = await deleteOldSeededExercisesForTopic(topic.id);
              log(`üßπ Usuniƒôto stare ƒáwiczenia importu: <code>${deleted}</code>`, 'muted');
            }

            const vocabItems = buildVocabItems(entry.sheet.rows);
            if (opt.updateMeta) {
              const metaRef = doc(db, 'course_meta', `${LEVEL}__${topic.id}`);
              await setDoc(
                metaRef,
                {
                  level: LEVEL,
                  courseId: topic.id,
                  vocab: vocabItems,
                  vocabCount: vocabItems.length,
                  vocabSeedSource: SEED_SOURCE,
                  vocabSeedVersion: SEED_VERSION,
                  updatedAt: serverTimestamp(),
                  createdAt: serverTimestamp(),
                },
                { merge: true },
              );
              log(`‚úÖ course_meta.vocab: <code>${vocabItems.length}</code>`, 'ok');
            }

            const exList = buildExercisesForTopic(
              topic,
              entry.sheet.name,
              entry.sheet.rows,
              opt,
            );
            const pairs = exList.map((x) => ({
              ref: doc(db, 'exercises', x.id),
              data: x.data,
            }));
            const written = await commitSetDocs(pairs);
            log(`‚úÖ exercises zapisane: <code>${written}</code>`, 'ok');
          }

          log(
            `‚úÖ Gotowe. Sprawd≈∫: <code>course.html?level=A1</code> ‚Üí temat ‚Üí <b>Ejercicios</b> + <b>Fichas</b>.`,
            'ok',
          );
        } catch (e) {
          console.error(e);
          log('‚ùå B≈ÇƒÖd importu. Sprawd≈∫ konsolƒô.', 'err');
        }
      });
    </script>
  </body>
</html>
